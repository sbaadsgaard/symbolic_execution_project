Proper testing of programs requires a good selection of input values that cover all edge cases of the program to ensure that it behaves as expected. Choosing such a selection is often a difficult and time consuming task, and so we risk ending up with a lackluster choice of test cases, which leaves large parts of the program untested. The goal of this report is to study \emph{symbolic execution}, which is a classical technique to systematically explore all execution paths of a program and generate concrete input values that will follow these execution paths and thereby obtain test cases that properly cover the entire program. To this, the program is executed symbolically by replacing the input values with symbolic values that represents arbitrary concrete values. Whenever a conditional statement is executed, there are two potential execution paths to follow. If both paths are feasible, the execution splits into two executions, each following a different path. Each execution keeps track of the constraints that the input values must satisfy to follow that path, and from these constraints we can derive concrete input values that will execute along the same path.
\\ 
We will also study a modern approach called \emph{concolic execution} that combines concrete and symbolic execution. In this technique, the program is executed with initially random concrete input values. During the execution, we maintain both symbolic and concrete values for all variables, and whenever the execution branches, the choice of branch is registered in a list of constraints, using the symbolic values. At the end of the execution, this list of constraints is used to generate a new set of concrete input values that will cause the program to execute along a different path. This process is repeated until all execution paths have been explored.
 
\iffalse
\newpage In chapter 2 we give a motivating example, to illustrate the usefulness of symbolic execution. In chapter 3 we will describe the principles of classical symbolic execution.  
 We will also study some key challenges and limitations to this technique. 
 In chapter 4 we will describe the principles of concolic execution. We will also be comparing the two techniques to see what advantages concolic execution offer over classical symbolic execution. Finally, in chapter 5 and 6 we demonstrate the principles of symbolic execution by implementing a concrete and a symbolic interpreter for a small toy language.  
 
 \fi