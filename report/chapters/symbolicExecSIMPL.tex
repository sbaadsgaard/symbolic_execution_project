In this chapter we will describe a symbolic interpreter for \explanguage. 

\section{Extension of grammar}

In order to symbolically interpret \explanguage, we must extend the grammar for the language, to include symbolic values. A symbolic value can either be a symbolic integer, a symbolic boolean or the unit value. 

\begin{grammar}
	<SV> ::= <SI> | <SB> | unit
\end{grammar}

A symbolic integer can either be a concrete integer, a symbol, or an arithmetic expression over these two.

\begin{grammar}
	<I> ::= 0 | 1 | -1 | 2 | -2 | $\ldots$
	
	<Sym> ::= a | b | c | \ldots
	
	<SI> ::= <I>
	\alt <Sym>	
	\alt <SI> + <SI> | <SI> - <SI> | <SI> * <SI> | <SI> / <SI>  
\end{grammar}

A symbolic boolean can either be \textsl{True}, \textsl{False} or a comparison of two symbolic integers. Finally, a symbolic boolean can be the negation of a symbolic boolean. This extension is needed to be able to represent the two different \emph{path-constraints} that might arise from a conditional statement.

\begin{grammar}
	<B> ::= True | False 
	
	<SB> :: = <B>
	\alt <SI> \textless <SI> | <SI> \textgreater <SI> | <SI> $\leq$ <SI> | <SI> $\geq$ <SI> | <SI> $==$ <SI>
	\alt ! <SB>
\end{grammar} 

Note that the definition of symbolic values also contain the concrete values, so we change the grammar of expressions to include symbolic values instead of just concrete values.

\begin{grammar}
	<E> ::= <SV>
\end{grammar}

\section{Path-constraints}
To represent a \pc, we implement the following classes

\begin{lstlisting}[style=simple]
case class PathConstraint(conds: List[SymbolicBool],
	ps: PathStatus)
	sealed trait PathResult
	case class Certain() extends PathResult
	case class Unknown() extends PathResult
\end{lstlisting}

This definition consists of two elements. \textsl{conds} is the list of conditions that must be met to follow the given execution path. The \textsl{PathStatus} tells us whether or not we can guarantee that the path constraint is in fact satisfiable. This is necessary because we allow for nonlinear constraints, which our \textbf{SMT} solver may fail to solve. In the case of a failure, we still explore the path but the status of the \pc will be \textsl{Unknown}.  

\section{Interpretation of expressions}
To interpret an expression, we define the following function

\begin{lstlisting}[style = simple]
 def interpExp(p: Prog,
  e: Exp, 
  env: HashMap[Id, SymbolicValue],
  pc: PathConstraint): List[ExpRes]
  
 case class ExpRes ExpRes(res: Result[SymbolicValue, String], 
 	pc: PathConstraint)
\end{lstlisting}
This definition is similar to the function from the concrete interpreter, except that the function now also takes a \pc as argument. The return type has also changed so that it now includes a \pc aswell. Further we return a list of such pairs, since expression can have several possible values depending on which execution path is followed. 

\subsection{Arithmetic and boolean expressions}
Consider an arithmetic expression 
\textsl{AExp(e1: Exp, e2: Exp, op: AOp)}. When we recursively interpret $e_1$ and $e_2$, we get two lists $L_{e_1}, L_{e_2}$ of possible results. We now need to take the cartesian $L_{e_1} \times L_{e_2}$ of the lists, and for each pair of results, we have to evaluate the arithmetic expression. 

To do this we use a \textsl{for-comprehension} which given two lists, iterate over each ordered pair of elements from the two lists.  For each pair, we \textsl{flatMap} over the two results, and if no errors are encountered, we check that both expressions evaluates to integers and compute the result.
\newpage
\begin{lstlisting}[style=simple]
	for {
		r1 <- interpExp(p, e1, env, pc)
		r2 <- interpExp(p, e2, env, r1.pc)
	} yield ExpRes(
		r1.res.flatMap(v1 => r2.res.flatMap(
		v2 => (v1, v2) match {
			case (i: IntValue, j: IntValue) => evalInts(i.v, j.v, op)
			case (i: SymbolicInt, j: SymbolicInt) => Ok(SymbolicAExp(i, j, op))
			case _ => Error("arithmetic operations on non integer values")
		})),
		r2.p
	)
\end{lstlisting}
Boolean expressions are interpreted in a similar fashion.

\subsection{Function calls}
Consider a Call expression \textsl{CallExp(id: Id, args: List[Exp])}.
To interpret this, we must first check that the function is defined and if not, we immediately return an \textsl{Error}. Otherwise, we check that the formal and actual argument list does not differ in length. Finally, if both of these things check out, we must interpret the expressions given in the \textsl{args} list, construct a local environment with the argument and interpret the statement in the function body. 
Given an argument list $[e_1, e_2, \ldots, e_n]$, we map \textsl{interpExp} on to the list, which gives a list of lists $[L_{e_1}, L_{e_2}, \ldots, L_{e_n}]$. Each list contains the possible values for the given argument, so from this we must construct all possible argument lists, which is the cartesian product over all $n$ lists $L_{e_1} \times L_{e_2} \times \ldots \times L_{e_n}$. For each possible argument list we attempt to build a local environment. If encounter an error during this process, either from the interpretation of the arguments, or from an argument having a unit value, this error will be the of function call with the given argument list. Otherwise the result will be the interpretation of the function body with the local environment. 

\section{Interpreting statements}