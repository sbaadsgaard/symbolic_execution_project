In this chapter we will introduce \emph{concolic execution}, which is a technique that combines concrete and symbolic execution to explore possible execution paths. We start by describing how the technique works, and then look at the advantages that it offers compared to only using symbolic execution. As in the previous chapter, we restrict our focus to programs that takes integer values as input, and performs arithmetic operations and comparisons on these. 

\section{Concolic execution of a program}
	During a symbolic execution of a program, we replace the inputs of the program with symbols that acts as placeholders for concrete integer value. The program environment maps variables to \emph{symbolic values}, which can either be integers, symbols or arithmetic expressions over these two. During a concolic execution of a program, we maintain two environments. One is a concrete environment $M_c$, which maps variables to concrete integer values. The other is a symbolic environment $M_s$ which maps variables to symbolic values. At the beginning of the execution, the concrete environment is initialized with a random integer value for each input. The symbolic environment is initialized with symbols for each input. 
	The program is then iteratively executed both concretely and symbolically. At the end of each iteration, we try do determine a new set of input values, that will cause the program to follow a different execution path in the next iteration. We do this until all execution paths have been explored, or some other predefined termination criteria is met. We will now describe what we mean by executing the program both concretely and symbolically. Specifically, we will explain how we maintain our environments, how we handle conditional statements and how we generate the next set of concrete input values \cite{Godefroid:2005:DDA:1064978.1065036}.
	
	\subsection{Maintaining the environments} 
	
	If we reach an assignment statement \textsl{x := e}, for some variable \textsl{v} and expression \textsl{e}, we evaluate \textsl{e} concretely and update our concrete environment. We also evaluate \textsl{e} symbolically and update our symbolic environment. 
	
	\subsection{Conditional statements}
	
	Whenever we reach a conditional statement with condition $q$, we evaluate $q$ concretely and chose a path accordingly. At the same time we evaluate $q$ symbolically and get some constraint $c$. If the concrete value of $q$ is true, we add $c$ to a \pc. If the concrete value of $q$ is false, we add $\neg c$ to the path constraint. This way track which choices of paths we have made during an iteration. 
	
	\subsection{Generating input values for next iteration}
	
	At the end of an iteration we will have a \pc that, for each encountered conditional statement, describes what choice of path we made. To generate a new set of input values, we make a new \pc by negating the final condition in the original \pc. If we end up with $pc = \lbrack c_1, c_2, \ldots, c_n \rbrack$, we make a new \pc $pc' = \lbrack c_1, c_2, \ldots, \neg c_n \rbrack$. We then solve the system of constraints from this \pc to get new concrete input values. If some input values are not constrained by the \pc we keep the current value for the next run.

\bigskip
To illustrate concolic execution, we consider the program from the motivating example:
\motexample
\newpage

\noindent First we initialize the two environments. We let 
\begin{equation*}
	M_c = \{units = 27, \ cost = 34\}
\end{equation*}
 where 27 and 34 is chosen randomly. We let
\begin{equation*}
 	M_s = \{units =\beta, \ cost = \alpha\}
\end{equation*}
where $\alpha$ and $\beta$ are symbols. The first statement is an assignment statement, so we get two new environments:

\begin{align*}
	M_c & = \{units = 27, \ cost = 34, \ revenue = 54 \}\\
	M_s & = \{units = \alpha, \ cost = \beta, \ revenue = 2\cdot \alpha \}
\end{align*}

Next, we reach an \textsl{if} statement with condition $revenue \geq 16$. Since $M_c(revenue) = 54$ we follow the \textsl{then} branch. We get a new \emph{path-constraint} which is $\lbrack (2\cdot \alpha \geq 16) \rbrack$. Next, we reach another \textsl{assign} statement, so we get the following environments:

\begin{align*}
	M_c & = \{units = 27, \ cost = 34, \ revenue = 44 \}\\
	M_s & = \{ units = \alpha, \ cost = \beta, \ revenue = 2 \cdot \alpha - 10 \}
\end{align*}

Next, we reach an \textsl{assert} statement which condition $revenue \geq cost$. Since $M_c(revenue) = 44$ the assertion succeeds. This gives us a new \emph{path-constraint} $\lbrack (2\cdot \alpha \geq 16) , ((2\cdot \alpha - 10) \geq \beta) \rbrack$. Finally we return 44, which finishes one execution path.\\
To discover a new \pc, we make a new \pc by negating the final condition of the current \pc, so we get $\lbrack (2\cdot \alpha \geq 16), \neg ((2\cdot \alpha - 10) \geq \beta) \rbrack$. To get the next set of concrete input values, $M_c$ we solve the system of constraints given by this \pc
\begin{align*}
	2\cdot \alpha \geq 16\\
	(2\cdot \alpha - 10) < \beta.
\end{align*}
This gives us e.g $\alpha = 8$ and $\beta = 7$. 
We then re execute the program with $units = 8$ and $cost = 7$. This execution will follow the same path until we reach the \textsl{assert}-statement. This time the execution results in an error due to the assertion being violated, and we have now explored all possible paths from the \textsl{assert}-statement. To generate the next input values, we negate the condition from the first \textsl{if}-statement and get $[\neg (2\cdot \alpha \geq 16)]$. From this we get e.g $\alpha = 5$. Since there are no constraints on the value of $\beta$, we keep the previous value.  We now re execute the program with $units = 5$ and $cost = 7$. This execution will not folow the \textsl{then} branch in the \textsl{if}-statement, so we immediately return $revenue$ which is 10. At this point we have explored all possible branches from each conditional statement, so we have explored all execution paths. 

\section{Handling undecidable \emph{path-constraints}} 
In the previous chapter we described how symbolic execution was limited by the ability to decide satisfiability of a \pc. For example, if we are execution a program with inputs $x$ and $y$ and encounter a non linear condition $ 5\cdot x - 10 \leq 3 \cdot y^3$, we might fail to decide the satisfiability of the two branches. In this case we can either let the execution fail, or assume that the paths are satisfiable and continue. In the first case, we potentially miss a large number of possible paths, and in the second case we can no longer guarantee that we only explore feasible paths.\\
The same issue may arise in concolic execution when generating the input values for the next iteration, but we are not left with same options as in symbolic execution. Since we always hfave access to both a concrete and a symbolic state, we can avoid having non linear conditions in the \pc. Non linear conditions comes from arithmetic operations involving multiplication or division, where both operands contain symbols. In this case we can instead choose to evaluate the expression with the concrete environment\cite{Godefroid:2005:DDA:1064978.1065036}. Consider the condition $ 5\cdot x - 10 \leq 3 \cdot y^3$ again. Assume that $y$ have concrete value $2$, we then evaluate the right-hand side and get $6$. The condition then becomes $ 5\cdot x - 10 \leq 24$, which is within the theory of integer linear arithmetic, which we know we can solve. This allows us to still explore more execution paths, without potentially exploring infeasible paths. 