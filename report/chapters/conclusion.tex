
We have demonstrated how symbolic execution, in principle, allows us to explore all possible execution paths for a program by executing the program using \emph{symbolic} values instead of concrete concrete input values. By keeping track of any constraints placed on these values by following a given execution path, we can solve these constraints to obtain concrete input values that follows the same path. This technique does have some limitations. One such limitation is the path explosion problem. The number of possible paths is potentially exponential in the number of conditional statements, and there might even be an infinite number of paths. Another limitation is the ability to decide whether a set of constraints is satisfiable or not. For some types of constraints this question is undecidable, and in this case we either have to give up exploring a large number of execution paths, or risk exploring paths that will never be executed by any concrete input values. We have also seen how this last limitation is partially mitigated by \emph{concolic execution}, where we combine concrete and symbolic execution. Here the program is executed with initially random concrete input values. During execution we maintain both symbolic and concrete values for the variables, and whenever the program branches, we keep track of which branch was chosen in a \emph{path-constraint}. This path-constraint is then used to generate the input for the next execution, which will follow a different path. By having access to both concrete and symbolic values, we can substitute symbolic values with concrete values if we ever encounter a path-constraint that we cannot solve. While this allows us to explore more paths without exploring infeasible paths, we still have to give up completeness, so the problem is not fully mitigated.

\noindent Finally we demonstrated symbolic execution by implementing both a concrete and a symbolic interpreter for a small toy language, which we compared to clearly see the differences between a concrete and symbolic execution and how the source language was extended to allow for symbolic execution. 
